<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Structural design patterns</title>
    <link rel="stylesheet" href="../../../assets/css/pages/StructuralDesignPatterns.css">
</head>
<body>
<ol>
    <li>
        <details>
            <summary>Adapter :</summary>
            <section class="rtl">
                <p class="bolder">
                    این design pattern زمانی استفاده میشود که بخواهیم
                    کلاسی را شبیه به کلاس دیگر بکنیم و بخواهیم
                    ابجکتی را با ابجکت دیگر replace کنیم بدون اینکه
                    کد client تغییری بکند --->
                </p>
                <p>
                    گاهی ممکن است در سیستم برای انجام یک کار از ابجکتی استفاده شود
                    و بعد از مدتی بخواهیم آن object را با object دیگری برای انجام ان کار replace کنیم
                </p>
                <p>
                    اما replace کردن object جدید باعث تغییرات زیادی در کد میشود زیرا ممکن
                    است ان object جدید متفاوت با ان object قبلی باشد !!!
                    <br>
                    مثلا نام متد هایش فرق کند و یا...
                </p>
                <p>
                    با استفاده از دیزاین پترن Adapter میتوانیم کلاس جدید را با کلاس قدیم
                    وفق دهیم و سازگار کنیم و ان ابجکت جدید را شبیه به ابجکت قدیم بکنیم
                    تا از تغییرات در کد client جلوگیری کنیم
                </p>
            </section>
        </details>
    </li>
    <li>
        <details>
            <summary>Bridge :</summary>
            <section class="rtl">
                <p class="bolder">
                    هدف این design pattern کم کردن implementation های
                    یک class و تبدیل implementation ها به کلاسی جداگانه و مجزا میباشد !!!
                    <br>
                    و عموما جایی استفاده میشود که از یک کلاس implementation های زیادی وجود داشته باشد===>
                </p>
                <p>
                    مثلا در سیستم یک abstract class ای داریم
                    که دارای یک abstract method میباشد !!!
                    <br>
                    به صورت پیشفرض به ازای هر implement ای که
                    میخواهیم برای ان abstract method انجام دهیم
                    ما باید ان کلاس را extends کنیم و ان
                    abstract method را implement کنیم !!!
                    <br>
                    پس اگر ان متد چندین functionality داشته باشد
                    باید به ازای هر functionality یکبار از ان کلاس extend شود
                    و ان متد implement شود که این کار باعث میشود
                    implementation های ما زیاد بشود !!!
                    <br>
                    این دیزاین پترن برای اینکه implementation ها را برای ان کلاس کم کند
                    آن کلاس را مجبور میکند هر implementation
                    را در قالب یک object از ورودی دریافت کند!!!
                    <br>
                    اینطوری از آن کلاسی که میتوانست implementation
                     های زیادی داشته باشد فقط یک instance میسازیم
                    و هر گاه خواستیم functionality متدی از کلاس را
                    تعویض کنیم از implementation مورد نظرمان یک
                    instance میسازیم و به ان کلاس پاس میدهیم !!!
                </p>
                <p>
                    1-برای اینکه در برنامه functionality ان abstract method را عوض کنیم باید
                    از کلاسی که برای functionality مورد نظر ما extends شده یک
                    instance بسازیم و ممکنه ساخت instance از ان
                    کلاسی که extends شده کاری تکراری و هزینه بر و سخت و زمانبر باشه
                    مثلا در constructor ان کلاس پارامتر های زیادی وجود داشته باشه !!!
                    با این دیزاین پترن دیگه نیاز نیست از ان کلاس instance بسازیم و
                    فقط از کلاسی instance میسازیم که
                    functionality متدی از ان کلاس را implement کرده !!!
                </p>
                <p>
                    2- ممکنه آن کلاس چندین abstract method داشته باشه که هر یک
                    از ان متدها functionality و implementation های مختلفی داشته باشند که ما به صورت پیشفرض
                    برای functionality هرabstract method باید آن کلاس را extend کنیم
                    و شاید هر بار که extend میکنیم نخواهیم functionality سایر متد ها را تغییر دهیم
                    و فقط باید functionality یک متد تغییر کند !!!
                    این design pattern با نوشتن functionality های هر متد در کلاس های جداگانه و دریافت ابجکت برای
                    functionality هر abstract method این مشکل را برای ما حل کرده !!!
                </p>
                <p>
                    3- با استفاده از این design pattern اگر برنامه نویس نهایی بخواهد functionality خودش را برای آن
                    abstract method کلاس پیاده سازی کند محدود به ساختاری که ما برایش تعیین کرده ایم نیست
                </p>
            </section>
        </details>
    </li>
    <li>
        <details>
            <summary>Composite:</summary>
            <section class="rtl text-right">
                <p>
                    <b>مکان استفاده:</b>
                    این design pattern در جایی استفاده میشود که
                    ساختار سیستم ما به صورت درختی و nested باشد
                    و ما بخواهیم در یک ابجکت چندین ابجکت
                    ازنوع و جنس خود ان ابجکت را compose کنیم (ارتباط یک به چند) :
                </p>
                <p>
                    مثل یک درایور و یا پارتیشن که درون ان میتواند
                    بینهایت فولدر و فایل به صورت تو در تو وجود داشته باشد
                    و یا یک منو که درون ان میتواند بینهایت ایتم
                    به صورت تو در تو وجود داشته باشد
                    ویا ساختار درختی کارکنان یک شرکت که هر کارمند
                    میتواند بینهایت زیر دست داشته باشد !!!
                </p>
                <hr>
                <p>
                    <b>هدف:</b>
                    <!--
                            بیشتر یکسان سازی هستش و اینکه این دیزاین پترن مارو مجبور میکنه
                            برگ ها و شاخه ها رو  کلا یک موجودیت در نظر بگیریم !!!
                    -->
                    هدف این دیزاین پترن یکسان سازی تمامی اعظا و موجودیت هایی که
                    در یک سیستم درختی وجود دارند با استفاده از
                    یک interface و یا abstract class میباشد
                    به علاوه با implement کردن این design pattern میتوانیم method ها و property های مشترک
                    بین تمام موجودیت هایی که در یک سیستم درختی وجود دارند را در یک abstraction جمع اوری کنیم !!!
                </p>
                <p>
                    <b>مثال :</b>
                    به صورت مثال اگر یک سیستم File manager را در نظر بگیریم ما میدانیم
                     هر فولدر و همچنین در هر پارتیشن یا درایو میتواند
                    فایل ها و یا فولدر هایی به صورت تو در تو وجود داشته باشد !!!
                </p>
                <p>
                    اگر از این design pattern برای پیاده سازیFile Manager استفاده نکنیم !!!
                    باید در موجودیت هایی مثل drive و folder دو property بسازیم
                    یکی برای نگه داری و compose کردن directory ها
                    و یکی برای نگه داری و compose کردن file ها !!!
                </p>
                <p>
                    اما اگر از این دیزاین پترن استفاده کنیم مجبور میشویم
                    کل اعظا و موجودیت های ساختار درختی File manager مان را
                    یعنی کلاس file و کلاس folder و کلاس drive را
                    با استفاده از interface و یا abstract class یکسان کنیم
                    و موجودیت های متفاوتی که در سیستم درختی File manager وجود دارد
                    را به چشم یک موجودیت نگاه کنیم و از یک نوع و یک جنس در نظر بگیریم که این باعث میشود :
                </p>
                <ol>
                    <li>
                        بتوانیم ابجکت هایی از جنس و نوع متفاوت
                        مثل file و folder را درون فقط یک property از object هایی
                        مثل drive و folder نگه داری و compose کنیم
                    </li>
                    <li>
                        متد ها و property های مشترک بین تمام موجودیت هایی
                        که در سیستم درختی ما وجود دارند مثل file , drive , folder را
                        در یک abstraction جمع اوری کنیم !!!
                    </li>
                </ol>
                <p>
                    <b> پیاده سازی: </b>
                    در این design pattern سه موجودیت داریم !!!
                </p>
                <ol>
                    <li>
                        <p class="bolder">
                            component :
                        </p>
                        <br>
                        این موجودیت abstract class و یا interface ای است که
                        شاخه ها و برگ هایی که در ساختار درختی ما هستند
                        از ان extends ویا implement میکنند !!!
                        و وظیفه این موجودیت تعریف method ها و property های
                        مشترک بین برگ و شاخه ها در ساختار درختی ما است !!!
                    </li>
                    <li>
                        <p class="bolder">composite :</p>
                        این موجودیت در ساختار درختی ما نقش
                        شاخه ها را ایفا میکند که از ان
                        برگ ها و شاخه های دیگری میتواند برویید
                        یعنی به عبارتی دیگر این موجودیت وظیفه
                        compose کردن شاخه و برگ ها و ابجکت هایی
                        از جنس component را بر عهده دارد و خود این
                        موجودیت هم از component ارث بری میکند !!!
                    </li>
                    <li>
                        <p class="bolder">
                            leaf :
                        </p>
                        این موجودیت در ساختار درختی ما
                        نقش برگ را ایفا میکند و از component
                        ارث بری میکند و این موجودیت دیگر ابجکتی از نوع
                        component را در خودش compose نمیکند !!!
                    </li>
                </ol>
                <p>
                    این دیزاین پترن پیمایش recursive بر روی شاخه ها و برگ های ساختار درختی ما را راحت تر میکند !!!
                </p>
            </section>
        </details>
    </li>
    <li>
        <details>
            <summary>Decorator:</summary>
            <section class="rtl text-right">
                <p>
                    <p>
                        هدف این design pattern اضافه کردن رفتار و قابلیت ها به صورت dynamic
                        به یک ابجکت مشخص از یک class بدون دستکاری در کلاس ان object و همچنین تغییر
                        (rename کردن method ها , اضافه کردن method های جدید , اضافه کردن مواردی به functionality متد ها)
                        یک کلاس بدون استفاده از امکان ارث بری و دستکاری در فایل ان کلاس میباشد !!!
                    </p>
                </p>
                <section>
                    این design patten در جایی استفاده میشود که :
                    <ol>
                        <li>
                            ما بخواهیم قابلیت هایی را فقط به یک object از یک کلاس اضافه کنیم
                            و اگر ان قابلیت ها را در کلاس ان object بنویسیم
                            آن قابلیت ها به تمام instance هایی که
                            از ان کلاس ساخته میشوند اعمال میشود !!!
                        </li>
                        <li>
                            میخواهیم یک کلاس را تغییر
                            (rename کردن method ها , اضافه کردن method های جدید , اضافه کردن مواردی به functionality متد ها)
                            دهیم اما امکان ارث بری از ان کلاس وجود ندارد
                            و نمیتوانیم فایل ان کلاس را به صورت مستقیم دستکاری کنیم !!!
                        </li>
                    </ol>
                </section>
                <p>
                    گاهی اوقات در سیستم کلاسی داریم که نام متد هایش مورد پسند ما نیست
                    و میخواهیم نام متد های ان کلاس را rename کنیم
                    ویا به functionality آن متد ها چیزی را اضافه بکنیم
                    و یا functionality آن متد را تغییر دهیم
                    و یا متد های دیگری برای انجام وظایفی به ان
                    کلاس و یا فقط به یکی از ابجکت هایی که
                    از ان کلاس تولید شده اضافه کنیم
                </p>
                <p>
                    اما به دلیل اینکه فایل ان کلاس readOnly است
                    ما نمیتوانیم متد های موردنظرمان را در ان کلاس rename کنیم
                    <br>
                    ویا به دلیل اینکه آن کلاس به صورت final تعریف شده
                    ما نمیتوانیم از ان کلاس extends کنیم و به
                    functionality متد های ان کلاس
                    چیزی را اضافه کنیم و یا functionality
                    متد های ان کلاس را تغییر دهیم و همچنین
                    متد های دیگری به ان کلاس اضافه کنیم
                    <br>
                    ویا به دلیل اینکه متد هایی که میخواهیم اضافه کنیم
                    فقط برای یکی از ابجکت های آن کلاس کاربرد دارد و ما
                    نمیخواهیم آن متد ها به همه ابجکت هایی که
                    از ان کلاس تولید میشوند apply شوند
                    پس ما نمیتوانیم به صورت مستقیم متد هایی که
                    میخواهیم اضافه کنیم را در ان کلاس بنویسیم
                </p>
                <p>
                    دیزاین پترن Decorator حل این مشکل را برای ما با ایجاد یک کلاس
                    و compose کردن یک ابجکت
                    |
                     از ان کلاسی که میخواهیم
                    بدون استفاده از ارث بری
                    و بدون دستکاری در فایل ان کلاس تغییر دهیم
                    و یا با compose کردن ان ابجکتی از کلاس که میخواهیم
                    قابلیت های اضافه تری به ان object اضافه کنیم
                    |
                    درون آن کلاسی که ایجاد کرده ایم امکان پذیر میکند !!!
                </p>
            </section>
        </details>
        <hr>
        <details>
            <summary>
                decorator :
            </summary>
            <!--
                    دسترسی نداشتن به کلاس اصلی برای اعمال تغییرات خود
                    مثلا فایل ای که ان کلاس درونش هست readonly باشه !!
                    ویا به علت final بودن ان کلاس نشه برای اعمال تغییرات ازش ارث بری کرد !!!
            -->
            <!--
                    در مکانی استفاده میشود که یک کلاس را میخواهیم با ارث بری تغییر دهیم اما ان کلاس final است و امکان ارث بری وجود ندارد
                    ویا میخواهیم متد های یک کلاس را تغییر نام دهیم اما فایل ان کلاس readOnly است
                     و امکان تغییر فایل ان کلاس به صورت مستقیم وجود ندارد !!!
             -->
            <!--
                    هدف این design pattern تغییر یک کلاس میباشد
                    و در موقعیت و مکانی استفاده میشود که
                    امکان ارث بری از یک کلاس وجود نداشته باشد
                    و همچنین امکان ویرایش فایلی که درونش ان کلاس نوشته شده وجود نداشته باشد !!!
            -->
            <!--
            ایجاد متد فقط برای یک ابجکت از یک کلاس
            در صورتیکه ان متد را در کلاس بنویسیم آن متد در تمام object هایی
            که از ان کلاس ساخته میشود وجود دارد اما ما فقط میخواهیم در یک ابجکت از ان کلاس ان متد وجود داشته باشد
            -->
            <section class="rtl text-right">
                <p>
                    <!--
                    اضافه کردن قابلیت فقط به یک object مشخص از یک کلاس به صورت داینامیک است
                    و در جایی استفاده میشود که بخواهیم قابلیت هایی را فقط به یک instance از یک کلاس اضافه کنیم !!!
                    -->
                    هدف این design pattern تغییر یک کلاس در جایی که
                    امکان ارث بری از ان کلاس وجود نداشته باشد و نتوانیم به صورت مستقیم فایل ان کلاس را ویرایش کنیم است !!
                    <!-- و یا بخواهیم توابعی به صورت پویا به object ان کلاس اضافهه کنیم !!! -->
                    <!--  و مسعولیت هایی را  به صورت داینامیک به ابجکت های ان کلاس اضافه کنیم !!! -->
                    ===>
                    تغییر یک کلاس در مکانی که ارث بری نیست و نمیشود به فایلش دسترسی پیدا کرد !!!
                    ======
                </p>
            </section>
        </details>
        <hr>
    </li>
    <li>
        <details>
            <summary>Facade:</summary>
            <section class="rtl text-right">
                <p class="bolder">
                    هدف این design pattern ساده کردن انجام یک کار مشخص
                    در کد نهایی برای برنامه نویس client و مخفی کردن پیچیدگی های
                    انجام ان کار مشخص در کد نهایی از چشم برنامه نویس client است
                    <br>
                    و بعلاوه این design pattern استفاده از کلاس های subSystem
                    مورد نیاز برای انجام یک کار مشخص را برای برنامه نویس client راحت تر میکند !!!
                </p>
                <p class="bolder">
                    همچنین این design pattern در جایی استفاده میشود که برنامه نویس client
                    باید برای انجام یک کار مشخص از کلاس های subSystem و متد هایشان استفاده کند
                    و با چندین object از کلاس های subSystem درگیر باشد که این باعث میشود
                    برنامه نویس client درگیر پیچیدگی های انجام ان کار شود
                    و همچنین کد نهایی پیچیده ، شلوغ و ناخوانا شود!!!
                </p>
                <section>
                    <p>
                        مثلا برای انجام یک کار مشخص برنامه نویس client
                        به چندین کلاس subsystem نیاز دارد و باید از متد های
                        چندین کلاس subSystem برای انجام ان کار در کد نهایی استفاده کند
                    </p>
                    <p>
                        برنامه نویس client برای اینکه بتواند ان کار مشخص را انجام دهد
                        ابتدا باید از ان کلاس های subsystem مطلع باشد و خبر داشته باشد
                        و سپس باید از ان کلاس های subsystem نمونه بسازد و از متد هایشان
                        برای انجام ان کار استفاده بکند !!!
                    </p>
                    <p>
                        که این باعث میشود برنامه نویس client با چندین ابجکت و متد
                        برای انجام ان کار درگیر شود و در نتیجه انجام ان کار
                        برای برنامه نویس client پیچیده و سخت میشود و همچنین
                        کد نهایی ما شلوغ و پیچیده میشود و خوانایی کد نهایی پایین می اید !!!
                    </p>
                    <p>
                        دیزاین پترن Facade این مشکل را برای برنامه نویس Client حل میکند به
                        این صورت که ما را مجبور میکند تا یک کلاس بسازیم
                        و یک instance از کلاس های subSystem ای که برای
                        انجام ان کار مشخص مورد نیاز است را درون آن کلاس compose کنیم
                        <br>
                        و بعلاوه میتوانیم در ان کلاس برای برنامه نویس client متد هایی شبیه به
                        متد هایی که در کلاس های subSystem وجود دارند ایجاد کنیم
                        <br>
                        و یا میتوانیم متدی را برای برنامه نویس client ،‌
                        در ان کلاس ایجاد کنیم که ان کار مشخص را انجام دهد !!!
                        <br>
                        و یا میتوانیم متد های getter ای را در ان کلاس برای برنامه نویس client
                        ایجاد کنیم که ابجکت هایی که از کلاس های subSystem ساخته شده اند
                        و درون ان کلاس compose شده اند را return کنند !!!
                    </p>
                    <p>
                        حالا برنامه نویس client زمانیکه میخواهد
                        ان کار مشخص را در کد نهایی انجام دهد
                        فقط با ساخت instance از کلاس facade
                        و درگیر شدن فقط با یک object
                    </p>
                    <ol>
                        <li>
                            میتواند به تمام object هایی از کلاس های subSystem
                            که برای انجام ان کار استفاده میشوند دسترسی داشته باشد
                        </li>
                        <li>
                            میتواند method هایی که برای انجام
                            ان کار مشخص در کلاس های subSystem وجود دارند را
                            مستقیما بر روی ابجکت کلاس facade صدا بزند
                            تا کلاس Facade معادل ان متد را از ابجکت مربوطه call کند !!!
                        </li>
                        <li>
                            میتواند متدی را که آن کار مشخص را انجام میدهد
                            را از ابجکت کلاس facade صدا بزند
                        </li>
                    </ol>
                    <p>
                        اینطوری برنامه نویس client به جای درگیر شدن با
                        چندین ابجکت از کلاس های subSystem برای انجام ان کار مشخص ،
                        فقط با ابجکت کلاس Facade درگیر میشود و

                        این باعث میشود انجام ان کار برای برنامه نویس client ساده باشد
                        و پیچیدگی انجام ان کار از چشم برنامه نویس نهایی مخفی شود
                        و در نتیجه کد نهایی پیچیده و شلوغ نمیشود
                    </p>
                </section>
                <ul>
                    <li>
                        این design pattern انجام یک کار مشخص را برای برنامه نویس client
                        آسان میکند و پیچیدگی ها را در انجام ان کار را از چشم برنامه نویس client مخفی میکند !!!
                    </li>
                    <li>
                        رابط دهنده چندین کلاس subsystem برای انجام یک کار مشخص
                    </li>
                    <li>
                        این design pattern رابطی برای راحت رسیدن به کلاس های subsystem برای انجام یک کار مشخص ایجاد میکند
                    </li>
                    <li>
                         command برای یک کلاس اما facade میتواند برای چندین کلاس باشد
                         و شاید متدی داشته باشد که از متد های چندین کلاس برای انجام یک کار استفاده کند !!!!
                        اما هر command دارای فقط یک متد و فقط برای انجام یک کار یا درخواست استفاده میشود
                        اما یک کلاس Facade میتواند چندین کار را انجام دهد و چندین متد داشته باشد‌!!!
                    </li>
                </ul>
            </section>
        </details>
    </li>

    <li>
        <details>
            <summary>FlyWeight:</summary>
            <section class="rtl text-right">
                <p class="bolder">
                    هدف این design pattern جلوگیری از ساخته شدن
                    object های یکسان از یک کلاس در RunTime ،
                    به منظور جلو گیری از اشغال بیهوده منابع سیستم میباشد !!!
                </p>
                <p class="bolder">
                    این design pattern در جایی استفاده میشود که
                    از یک کلاس instance های متعددی ساخته میشود
                    و نمیخواهیم برنامه نویس client از آن کلاس object های یکسان و تکراری تولید کند
                    و نمیخواهیم منابع سیستم ما برای ان کار ، بیهوده مصرف شود زیرا ممکن است
                    ساخت هر object از یک کلاس هزینه بر باشد و منابع سیستم ما را بیهوده اشغال کند !!!
                </p>
                <p>
                    گاهی اوقات در سیستم یک کلاس داریم که میدانیم از ان object های متعددی ساخته میشود
                    و همچنین ممکن است ساخت هر object از ان کلاس هزینه بر باشد و منابع سیستم را اشغال و درگیر کند !!!!
                </p>
                <p>
                    ممکن است برنامه نویس client از ان کلاس ، ‌چندین object یکسان بسازد
                    که این کار باعث هدر رفتن منابع سیستم و همچنین باعث به‌ وجود
                    امدن مشکل sync نبودن object های یکسان با یکدیگر در زمان تغییر میشود به عبارتی دیگر
                    وقتی بر روی ابجکتی که در runTime مشابه هایی دارد تغییری اعمال کنیم ان تغییرات
                    فقط بر روی خود ان object اعمال میشود و بر روی object های مشابه به ان apply نمیشود !!!
                </p>
                <p>
                    دیزاین پترن flyWeight این مشکلات را برای ما حل میکند
                    به این صورت که ما را مجبور میکند تا یک کلاس بسازیم
                    و در آن کلاس یک ارایه را برای compose کردن object های
                    آن کلاسی که میتواند دارای instance های متعددی باشد ،‌ تعریف کنیم
                </p>
                <p>
                    و سپس این design pattern ما را در کلاس FlyWeight مجبور میکند تا یک method بسازیم
                    تا با استفاده از ان method ساخت object از ان کلاس را مدیریت کنیم
                    و با cache کردن object های unique ای که از ان کلاس ساخته میشوند
                    در ان ارایه ،‌ از ایجاد object های یکسان از ان class جلوگیری کنیم !!!
                </p>
                <ul>
                    <li>
                        دیزاین پترن singleton فقط یکبار از کلاس instance میساخت
                        اما این دیزاین پترن به ما اجازه میده چندین object از یک کلاس
                        داشته باشیم منتها جلوی ساخت ابجکت هایی که قبلا ساخته شده اند را میگیرد
                    </li>
                    <li>
                        در صورتیکه نیاز داشتیم تا از دو ابجکت یکسان بسازیم
                        و این دیزاین پترن مانع این کار میشد !!!‌
                        میتوانیم از دیزاین پترن Prototype برای clone کردن ابجکت هایی
                        که ساخته شده و در کلاس FlyWeight نگه داری شده استفاده کنیم
                    </li>
                </ul>
            </section>
        </details>
    </li>
    <li>
        <details>
            <summary>Proxy:</summary>
            <section class="rtl text-right">
                <p class="bolder">
                    هدف این design pattern برسی کردن درخواستی که یک unit میخواهد با ان درخواست اجرا شود ،
                    با استفاده از ایجاد یک یونیت wrapper برای unit اصلی میباشد !!!
                </p>
                <p class="bolder">
                    این design pattern در جایی استفاده میشود که میخواهیم درخواستی را که
                    برنامه نویس client در کد نهایی برای اجرای یک unit میفرستد را
                    برسی کنیم و اگر صلاح دیدیم آن unit را با ان درخواست اجرا کنیم
                    و یا ان درخواست را به ان unit اطلاع دهیم
                </p>
                <p>
                    مثلا برنامه نویس client در کدنهایی میخواهد درخواستی را به یک unit برای اجرا بفرستد اما
                    ابتدا ان درخواست باید برسی شود و در صورت صلاحدید ان unit با ان درخواست اجرا شود !!!
                </p>
                <p>
                    پس برنامه نویس client در کد نهایی با استفاده از شرط ها شروع به برسی ان
                    درخواستی که یک unit میخواهد با ان اجرا شود میکند !!!
                    و سپس در RunTime در صورتی که ان شرط ها true باشند
                    آن unit با ان درخواست اجرا میشود !!!
                </p>
                <p>
                    اما اینکار باعث میشود برنامه نویس client در کد نهایی درگیر برسی
                    درخواستی شود که یک unit باید با ان اجرا شود و همچنین اینکار باعث میشود
                    کد نهایی ما پیچیده و کثیف و ناخوانا شود مخصوصا اگر برنامه نویس client
                    برای برسی ان درخواست در کد نهایی ، از شرط های تو در تو استفاده کرده باشد !!
                </p>
                <p>
                    برای اینکه برنامه نویس client در کد نهایی ،‌ درگیر پیچیدگی برسی درخواستی که یک unit میخواهد با ان اجرا شود ،
                    نباشد میتوانیم از دیزاین پترن proxy استفاده کنیم به این صورت که این design pattern ما را مجبور میکند تا
                    در یک یونیت wrapper مجزا ، درخواستی را که unit اصلی میخواهد با ان اجرا شود را برسی کنیم
                    و در صورت صلاحدید آن درخواست را به unit اصلی اطلاع دهیم و یا unit اصلی را با ان درخواست اجرا کنیم !!
                </p>
                <p>
                    حالا برنامه نویس client با ارسال کردن درخواست 
                </p>
                <section>
                    <h1> نکات تکمیلی :‌</h1>
                    <ul>
                        <li>
                            مفهوم proxy در برنامه نویسی یعنی ایجاد یک یونیت wraper برای یک unit دیگر
                            که وقتی برنامه نویس client در کد نهایی به ان یونیت wraper درخواستی ارسال کرد
                            ان یونیت wraper اگر صلاح دید ان درخواست را به unit اصلی تحویل و اطلاع دهد ویا ان
                            یونیت wrapper درصورت صلاحدید یونیت اصلی را با ان درخواست call کند
                        </li>
                        <li>
                            با استفاده از دیزاین پترن proxy یک کاری که
                            در کد نهایی باید به صورت conditional انجام شود را
                            در یک unit مجزا برای برنامه نویس کلاینت
                            encapsulate میکنیم
                        </li>
                        <li>
                            مثلا اگر بخواهیم page caching را در لاراول پیاده سازی کنیم این design pattern
                            برای ما مفید واقع میشود زیرا زمانی که میخواهیم دیتای یک صفحه را بگیریم
                            ابتدا باید برسی کنیم ان دیتا از قبل در cache وجود دارد یا خیر !!!
                        </li>
                    </ul>
                </section>

            </section>
        </details>
    </li>
</ol>
</body>
</html>
