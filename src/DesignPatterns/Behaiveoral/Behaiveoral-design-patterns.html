<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <link rel="stylesheet" href="../../../assets/css/pages/BehavioralDesignPatterns.css">
</head>
<body>
<ol>
  <li>
    <details>
      <summary>Chain Of Responsibility :</summary>
      <section class="rtl text-right">
        <p class="bolder">
          هدف این دیزاین پترن encapsulate کار هایی که باید پشت سر هم انجام شوند
          در unit های مجزا و سپس متصل کردن ان unit ها به یکدیگر به صورت
          دانه های یک زنجیر میباشد به طوری که هر unit
          باید از unit بعدی خود که قرار است اجرا شود مطلع باشد
          و هر unit باید بتواند unit بعد از خودش را اجرا کند !!
        </p>
        <p class="bolder">
          <!--
          برای انجام یک تسک باید چندین کار پشت سر هم انجام شود و برای انجام شدن هر کار باید از یک موجودیت و متد هایش استفاده کرد
          -->
          زمانی از این design pattern استفاده میکنیم که برای انجام شدن یک task ،
          باید چندین کار  |توسط موجودیت های مختلف |، به صورت پشت سر هم انجام شود و ما میخواهیم به صورت داینامیک
          هر گاه که نیاز بود ، کاری را به ان زنجیره اضافه و یا کم کنیم !!!
        </p>
        <p>
          <!-- یک تسک : چندین کار : هر کار یک موجودیت -->
          مثلا برنامه نویس client ما نیاز دارد تا یک task را با استفاده از انجام شدن
          چندین کار پشت سر هم انجام دهد اما برنامه نویس client باید
          به ازای انجام هر کار در کد نهایی ، از یک موجودیت و method هایش استفاده کند :
          <br>
          <img src="../../../assets/img/ChainOfResponsibility1.svg" alt="" class="">
        </p>
        <p>
          ممکن است استفاده از هر موجودیت و متد هایش برای انجام یک کار ،
          در کد نهایی پیچیدگی هایی را به همراه داشته باشد
          و ما نمیخواهیم برنامه نویس client ما درگیر ان پیچیدگی ها شود
          و همچنین کد نهایی ما پیچیده و شلوغ و کثیف شود !!!
        </p>
        <p>
          در اینجا برای حل این مشکل میتوانیم از دیزاین پترن
          chain of responsibility استفاده کنیم به این
          صورت که این design pattern ما را محبور میکند تا
          هر کاری را که بواسطه استفاده از یک موجودیت و متد هایش
          برای انجام ان task در کدنهایی انجام داده ایم را در یک
          unit مجزا encapsulate کنیم
          <!--
          وصل بودنه واسه اینه که پشت سر هم انجام بشه ؟؟؟
           میخاد این گارانتی رو بده که پشت سر هم انجام میشه و اجرا میشه و هیچ چیزی بینشون اجرا نمیشه ؟؟؟

          انجام هر کار و پیچیدگی اش را داخل یک یونیت مجزا encapsulate کنیم
          -->
        </p>
        <p>
          اینطوری پیچیدگی انجام هر کار در unit های مجزا encapsulate ،
          و از چشم برنامه نویس client مخفی میشود و دیگر لازم نیست
          برنامه نویس client با پیچیدگی انجام هر کار درگیر شود و همچنین
          برنامه نویس client میتواند هر گاه که نیاز بود به صورت داینامیک
          به ان زنجیره ای از کار ها ، کاری را اضافه و یا کم کند و در نتیجه بواسطه
          این design pattern کد نهایی ما تمیز و ساده و خوانا میشود !!!
        </p>
      </section>
      <section class="rtl text-right">
        <h1>نکات تکمیلی :‌</h1>
        <ol>
          <li>
            <details>
              <summary>
                تفاوت Chain Of Responsibility با command :
              </summary>
              <section>
                <p>
                  زمانی از دیزاین پترن command استفاده میشود که برای انجام
                  یک task فقط با یک موجودیت و method هایش سروکار داشته باشیم !!!
                  <br>
                  اما زمانی از دیزاین پترن chain of responsibility استفاده میکنیم
                  که برای انجام یک task با چندین موجودیت  و method هایشان درگیر باشیم !!!
                </p>
                <p>
                  از موجودیت های command میتوان درون chain of responsibility استفاده کرد !!!
                </p>
              </section>
            </details>
          </li>
          <li>
            تفاوت با observer :
          </li>
        </ol>
      </section>
    </details>
  </li>


  <li>
  <details>
    <summary>Command:</summary>
    <section class="rtl text-right">
      <p class="bolder">
        هدف این دیزاین پترن encapsulate درخواست هایی که به یک unit ارسال میشود در unit های مجزا میباشد
      </p>
      <p class="bolder">
        در جایی استفاده میشود که برای انجام یک task باید متد هایی از یک کلاس پشت سر هم صدا زده بشود
      </p>
      <p>
        مثلا برنامه نویس کلاینت ما میخواهد یک task ای را انجام دهد که برای انجام شدن ان task
        باید فقط از method های یک موجودیت استفاده استفاده کند
      </p>
    </section>
  </details>
</li>




  <li>
    <details>
      <summary>Observer:</summary>
      <section class="text-right rtl">
        در این chain اگر به هر دلیلی انجام یک کار fail شد عموما دیگر به سراغ انجام کار بعدی نمیرویم

        ===
        در chainOfRes انجام کار های پشت سر هم و متصل به هم و اگر در هر کار عملیات return انجام شود
        دیگر ادامه کار ها اجرا نمیشود
        اما در این الگو اگرreturn شود همچنان ادامه اجرا برقرار است !!!
        ====
        توی observer یک unit مسعول ذخیره هستش و ان یونیت با حلقع کار ها  را اجرا میکند
        اما در chain ما یونیتی که chain ها را ذخیره کند نداریم و هر unit باید از یونیت بعد از خودش اطلاع داشته باشد و انرا اجرا کند !!!
      </section>
    </details>
  </li>
  <li>
    <details>
      <summary>Visitor:</summary>
      <section class="rtl text-right">
        <p>
          هدف این design pattern
          <!--
          عملیاتی که باید بر روی یک object انجام شود در class های مجزا
          -->
          <!--
          یک ابجکت را در یک سیستم قابل visit شدن میکند تا و همچنین عملیات هایی که باید بر روی ان انجام شود را
          در کلاس های مجزا ....
          -->
          <!--
          و همچنین کاری میکند تا عملیاتی که باید بر روی یک ابجکت انجام شود در کلاس های مجزا پیاده سازی بشوند !!!
          -->
        </p>
      </section>
    </details>
  </li>
  <li>
    <details>
      <summary>Interpreter:</summary>
      <section class="rtl text-right">
        <p class="bolder">
          هدف این دیزاین پترن parse کردن یک string معنا دار
          به object میباشد
        </p>
      </section>
    </details>
  </li>
</ol>
</body>
</html>