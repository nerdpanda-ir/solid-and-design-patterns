<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Behavioral-design-patterns</title>
  <link rel="stylesheet" href="../../../assets/css/pages/BehavioralDesignPatterns.css">
</head>
<body>
<ol>
  <li>
    <!--
    داینامیک بودن
    اضافه کردن handler
    -->
    <details>
      <summary>Chain Of Responsibility :</summary>
      <section class="rtl text-right">
        <section>
          هدف دیزاین پترن Chain Of Responsibility :
          <ol>
            <li>
              <p class="bolder">
                encapsulate کار هایی که باید برای انجام یک task ،
                پشت سر هم انجام شوند در unit های مجزا است
              </p>
            </li>
            <li>
              <p class="bolder">
                <!-- به منظور اجرای پشت سر هم ؟؟؟ -->
                متصل کردن ان unit ها به یکدیگر به صورت دانه های یک زنجیر ،
                به طوری که هر unit باید از unit بعدی خود که قرار است اجرا شود مطلع باشد
                و هر unit باید بتواند unit بعد از خودش را اجرا کند !!
              </p>
            </li>
          </ol>
        </section>
        <section>
          زمانی از این design pattern استفاده میکنیم که :
          <ol>
            <li>
              <p class="bolder">
                برای انجام شدن یک task ، باید چندین کار ، به صورت پشت سر هم انجام شود
                و یا باید برای انجام ان task باید چندین handler پشت سرهم اجرا شود !!!
              </p>
            </li>
            <li>
              <p class="bolder">
                ما میخواهیم هر گاه که نیاز بود به صورت Dynamic
                کاری ویا handler ی را به ان زنجیره اضافه و یا کم کنیم !!!
              </p>
            </li>
          </ol>
        </section>
        <p>
          مثلا برنامه نویس client ما نیاز دارد تا یک task را با استفاده از انجام شدن
          چندین کار پشت سر هم انجام دهد اما برنامه نویس client باید
          به ازای انجام هر کار در کد نهایی ، از یک موجودیت و method هایش استفاده کند :
          <br>
          <img src="../../../assets/img/ChainOfResponsibility1.svg" alt="" class="">
        </p>
        <p>
          ممکن است استفاده از هر موجودیت و متد هایش برای انجام یک کار ،
          در کد نهایی پیچیدگی هایی را به همراه داشته باشد
          و ما نمیخواهیم برنامه نویس client ما درگیر ان پیچیدگی ها شود
          و همچنین کد نهایی ما پیچیده و شلوغ و کثیف شود !!!
        </p>
        <p>
          در اینجا برای حل این مشکل میتوانیم از دیزاین پترن
          chain of responsibility استفاده کنیم به این
          صورت که این design pattern ما را محبور میکند تا
          هر کاری را که بواسطه استفاده از یک موجودیت و متد هایش
          برای انجام ان task در کدنهایی انجام داده ایم را در یک
          unit مجزا encapsulate کنیم و این امکان را به ان unit بدهیم که
          بتواند در کد نهایی به یک unit دیگر از جنس خودش متصل شود !!!
        </p>
        <img src="../../../assets/img/ChainOfResponsibility2.svg" alt="">
        <p>
          <!--
              وصل بودنه واسه اینه که پشت سر هم انجام بشه ؟؟؟
              میخاد این گارانتی رو بده که پشت سر هم انجام میشه و اجرا میشه و هیچ چیزی بینشون اجرا نمیشه ؟؟؟

              و با متصل کردن به برنامه نویس کلاینت این گارانتی را دهده ایم ....

              و همچنین ما با متصل کردن ان کار ها به یگدیگر مثل یک زنجیر ، این گارانتی را داده ایم
              که ان کار ها پشت سر هم انجام شوند و بین انها هیچ چیز اضافه تری انجام نشود
              2- برنامه نویس client به صورت Dynamic بتواند کار جدیدی را به ان زنجیره ای از کار ها اضافه کند و یا کم کند
            -->
          اینطوری پیچیدگی انجام هر کار در unit های مجزا encapsulate ،
          و از چشم برنامه نویس client مخفی میشود و دیگر لازم نیست
          برنامه نویس client با پیچیدگی انجام هر کار درگیر شود و همچنین
          برنامه نویس client میتواند هر گاه که نیاز بود به صورت داینامیک
          به ان زنجیره ای از کار ها ، کاری را اضافه و یا کم کند و در نتیجه بواسطه
          این design pattern کد نهایی ما تمیز و ساده و خوانا میشود !!!
        </p>
      </section>
      <section class="text-right rtl">
        <h1>نکات تکمیلی :‌</h1>
        <ol>
              <li>
                <details>
                  <summary>
                    تفاوت Chain Of Responsibility با command :
                  </summary>
                  <section>
                    <p>
                      زمانی از دیزاین پترن command استفاده میشود که برای انجام
                      یک task فقط با یک موجودیت و method هایش سروکار داشته باشیم !!!
                      <br>
                      اما زمانی از دیزاین پترن chain of responsibility استفاده میکنیم
                      که برای انجام یک task با چندین موجودیت و method هایشان درگیر باشیم !!!
                    </p>
                    <p>
                      از موجودیت های command میتوان درون chain of responsibility استفاده کرد !!!
                    </p>
                    <img src="../../../assets/img/ChainOfResponsibility3.svg" alt="" style="with:100%;">
                  </section>
                </details>
              </li>
              <li>
                تفاوت با observer :
              </li>
            </ol>
      </section>
    </details>
  </li>





  <li>
    <details>
      <summary>Command:</summary>
      <section class="rtl text-right">
        <p class="bolder">
          هدف این دیزاین پترن encapsulate درخواست هایی که به یک unit ارسال میشود در unit های مجزا میباشد
        </p>
        <p class="bolder">
          در جایی استفاده میشود که برای انجام یک task باید متد هایی از یک کلاس پشت سر هم صدا زده بشود
        </p>
        <p>
          مثلا برنامه نویس کلاینت ما میخواهد یک task ای را انجام دهد که برای انجام شدن ان task
          باید فقط از method های یک موجودیت استفاده استفاده کند
        </p>
      </section>
    </details>
  </li>




  <li>
    <details>
      <summary>Observer:</summary>
      <section class="text-right rtl">
        در این chain اگر به هر دلیلی انجام یک کار fail شد عموما دیگر به سراغ انجام کار بعدی نمیرویم

        ===
        در chainOfRes انجام کار های پشت سر هم و متصل به هم و اگر در هر کار عملیات return انجام شود
        دیگر ادامه کار ها اجرا نمیشود
        اما در این الگو اگرreturn شود همچنان ادامه اجرا برقرار است !!!
        ====
        توی observer یک unit مسعول ذخیره هستش و ان یونیت با حلقع کار ها  را اجرا میکند
        اما در chain ما یونیتی که chain ها را ذخیره کند نداریم و هر unit باید از یونیت بعد از خودش اطلاع داشته باشد و انرا اجرا کند !!!
      </section>
    </details>
  </li>


  <li>
    <details>
      <summary>Visitor:</summary>
      <section class="rtl text-right">
        <p>
          هدف این design pattern
          <!--
          عملیاتی که باید بر روی یک object انجام شود در class های مجزا
          -->
          <!--
          یک ابجکت را در یک سیستم قابل visit شدن میکند تا و همچنین عملیات هایی که باید بر روی ان انجام شود را
          در کلاس های مجزا ....
          -->
          <!--
          و همچنین کاری میکند تا عملیاتی که باید بر روی یک ابجکت انجام شود در کلاس های مجزا پیاده سازی بشوند !!!
          -->
        </p>
      </section>
    </details>
  </li>

  <li>
    <details>
      <summary>Interpreter:</summary>
      <section class="rtl text-right">
        <p class="bolder">
          هدف این دیزاین پترن parse کردن یک string معنا دار
          به object میباشد
        </p>
      </section>
    </details>
  </li>
</ol>
</body>
</html>