<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Behavioral-design-patterns</title>
  <link rel="stylesheet" href="../../../assets/css/pages/BehavioralDesignPatterns.css">
</head>
<body>
<ol>
  <li>
    <!--
    داینامیک بودن
    اضافه کردن handler
    -->
    <details>
      <summary>Chain Of Responsibility :</summary>
      <section class="rtl text-right">
        <section>
          هدف دیزاین پترن Chain Of Responsibility :
          <ol>
            <li>
              <p class="bolder">
                encapsulate کار هایی که باید برای انجام یک task ،
                پشت سر هم انجام شوند در unit های مجزا است
              </p>
            </li>
            <li>
              <p class="bolder">
                متصل کردن ان unit ها به یکدیگر در کد به صورت دانه های یک زنجیر ،
                به طوری که هر unit باید از unit بعدی خود که قرار است اجرا شود مطلع باشد
                و هر unit باید بتواند unit بعد از خودش را اجرا کند !!
              </p>
            </li>
          </ol>
        </section>
        <section>
          زمانی از این design pattern استفاده میکنیم که :
          <ol>
            <li>
              <p class="bolder">
                برای انجام شدن یک task ، باید چندین کار ، به صورت پشت سر هم انجام شود
                و یا باید برای انجام ان task باید چندین handler پشت سرهم اجرا شود !!!
              </p>
            </li>
            <li>
              <p class="bolder">
                ما میخواهیم هر گاه که نیاز بود به صورت Dynamic
                کاری ویا handler ی را به ان زنجیره اضافه و یا کم کنیم !!!
              </p>
            </li>
          </ol>
        </section>
        <p>
          مثلا برنامه نویس client ما نیاز دارد تا یک task را با استفاده از انجام شدن
          چندین کار پشت سر هم انجام دهد اما برنامه نویس client باید
          به ازای انجام هر کار در کد نهایی ، از یک موجودیت و method هایش استفاده کند :
          <br>
          <img src="../../../assets/img/ChainOfResponsibility1.svg" alt="" class="">
        </p>
        <p>
          ممکن است استفاده از هر موجودیت و متد هایش برای انجام یک کار ،
          در کد نهایی پیچیدگی هایی را به همراه داشته باشد
          و ما نمیخواهیم برنامه نویس client ما درگیر ان پیچیدگی ها شود
          و همچنین کد نهایی ما پیچیده و شلوغ و کثیف شود !!!
        </p>
        <p>
          در اینجا برای حل این مشکل میتوانیم از دیزاین پترن
          chain of responsibility استفاده کنیم به این
          صورت که این design pattern ما را محبور میکند تا
          هر کاری را که بواسطه استفاده از یک موجودیت و متد هایش
          برای انجام ان task در کدنهایی انجام داده ایم را در یک
          unit مجزا encapsulate کنیم و این امکان را به ان unit بدهیم که
          بتواند در کد نهایی به یک unit دیگر از جنس خودش متصل شود !!!
        </p>
        <img src="../../../assets/img/ChainOfResponsibility2.svg" alt="">
        <p>
          اینطوری پیچیدگی انجام هر کار در unit های مجزا encapsulate ،
          و از چشم برنامه نویس client مخفی میشود و دیگر لازم نیست
          برنامه نویس client با پیچیدگی انجام هر کار درگیر شود
          و همچنین با متصل شدن ان unit ها به یکدیگر در کدنهایی مثل یک زنجیر ،
          به برنامه نویس کلاینت این گارانتی داده میشود که آن کار ها حتما پشت سر هم
          انجام میشوند و بین انها هیچ وقفه ای برای انجام کار دیگری و یا .... نیوفتد
          و بعلاوه به برنامه نویس client این گارانتی داده میشود که بتواند به صورت Dynamic
          هر گاه که نیاز داشت کار و یا handler ای را به ان زنجیره اضافه و یا کم کند !!!
          و در نتیجه بواسطه این design pattern کد نهایی ما تمیز و ساده و خوانا میشود !!!
        </p>
      </section>
      <section class="text-right rtl">
        <h1>نکات تکمیلی :‌</h1>
        <ol>
              <li>
                <details>
                  <summary>
                    تفاوت Chain Of Responsibility با command :
                  </summary>
                  <section>
                    <p>
                      زمانی از دیزاین پترن command استفاده میشود که برای انجام
                      یک task فقط با یک موجودیت و method هایش سروکار داشته باشیم !!!
                      <br>
                      اما زمانی از دیزاین پترن chain of responsibility استفاده میکنیم
                      که برای انجام یک task با چندین موجودیت و method هایشان درگیر باشیم !!!
                    </p>
                    <p>
                      از موجودیت های command میتوان درون chain of responsibility استفاده کرد !!!
                    </p>
                    <img src="../../../assets/img/ChainOfResponsibility3.svg" alt="" style="with:100%;">
                  </section>
                </details>
              </li>
              <li>
                تفاوت با observer :
              </li>
            </ol>
      </section>
    </details>
  </li>
  <li>
    <details>
      <summary>Command:</summary>
      <section class="rtl text-right">
        <p class="bolder">
          هدف این دیزاین پترن encapsulate درخواست ای که برای انجام یک task
          به یک Entity ارسال میشود در یک unit مجزا میباشد
        </p>
        <p class="bolder">
          در جایی استفاده میشود که برای انجام یک task باید
          متد هایی از یک کلاس ، پشت سر هم صدا زده بشود
        </p>
        <p>
          مثلا برنامه نویس client ما میخواهد یک task ای را انجام دهد و برای انجام ان
          task نیاز دارد تا چندین Method را از یک موجودیت به صورت پشت سر هم صدا بزند
          اما اینکار باعث میشود برنامه نویس client ما برای انجام ان task با آن موجودیت
          و متد هایش درگیر شود و همچنین اگر برنامه نویس client ما متد های زیادی را از ان موجودیت
          برای انجام ان task پشت سر هم صدا بزند ، کد نهایی ما پیچیده و شلوغ و کثیف میشود !!!
        </p>
        <p>
          برای حل این مشکل میتوانیم از دیزاین پترن command استفاده کنیم
          به این صورت که این design pattern مارا مجبور میکند تا متد هایی را
          که از ان موجودیت برای انجام ان task پشت سر هم صدا زده ایم را در یک
          unit مجزا encapsulate کنیم
        </p>
        <p>
          اینطوری برنامه نویس client ما برای انجام ان task درگیر استفاده از چندین method از یک موجودیت نمیشود
          زیرا بواسطه دیزاین پترن command میتواند با صدا زدن یک method از یونیت command ، ان task را انجام دهد
          و همچنین استفاده از دیزاین پترن command باعث شده که کد نهایی ما شلوغ ، پیچیده ، و کثیف نشود !!!
        </p>
      </section>
      <section class="rtl text-right">
        <details>
          <summary class="bolder">نکات تکمیلی :</summary>
          <ol>
            <li>
              این design pattern موجودیت هایی را ایجاد میکند که کار ان موجودیت ها
              انجام یک درخواست با استفاده از یک unit است !!!
            </li>
            <li>
              این design pattern زمانی مفید واقع میشود که یک تسک باید به واسطه متد های یک موجودیت انجام شود
            </li>
            <li>
              <details>
                <summary>تفاوت دیزاین پترن command با Facade : </summary>
                <section>
                  command برای یک کلاس اما facade میتواند برای چندین کلاس باشد
                  و شاید متدی داشته باشد که از متد های چندین کلاس برای انجام یک کار استفاده کند !!!!
                  اما هر command دارای فقط یک متد و فقط برای انجام یک کار یا درخواست از یک موجودیت استفاده میشود
                  اما یک کلاس Facade میتواند چندین کار را انجام دهد و چندین متد داشته باشد‌!!!
                </section>
              </details>
            </li>
            <li>
              میتوانیم command هایی ایجاد کنیم و به عنوان callBack بدهیم به ابجکت ها
              تا هر موقع نیاز بود ان کامنتد ها را اجرا کنند مثلا دو کامند success , fail میسازیم
              و ان دو را پاس میدهیم به یک ابجکت حالا ان ابجکت هر موقع که یک کاری با موفقیت انجام داد
              به ابجکت کامند success درخواست میدهد تا اجرا شود اما اگر انجام ان کار Fail شد
              به کامند Fail درخواست میدهد تا اجرا شود !!!
            </li>
            <li>
              <p>
                این design pattern اصل single responsibility را برای متد هایمان مهیا میسازد یعنی هر متد
                باید یک کار انجام دهد و اگر متدی در ان کلاس داریم که باید بواسطه متد های دیگر ان کلاس ،
                یک کاری را انجام داده آن متد اصل single responsibility را نقض کرده !!!
              </p>
              <p>
                با استفاده از دیزاین پترن command میتوانیم این مشکل را حل کنیم و در هیچ کلاسی متدی نداشته باشیم
                که بواسطه متد های دیگر از همان کلاس کاری را انجام دهد !!!
              </p>
            </li>
            <li>
              <p>
                میتوانیم در یک موجودیت command ، چندین متد helper داشته باشیم
                که هر یک از آنها ، متد هایی را از ابجکت اصلی پشت سر هم صدا میزنند !!!
              </p>
              <p>
                سپس در زمانیکه متدی از موجودیت command برای انجام درخواست اجرا شد
                میتوانیم ان متد های helper را در ان متد صدا بزنیم !!!
              </p>
            </li>
          </ol>
        </details>
      </section>
    </details>
  </li>
  <li>
    <details>
      <summary>Interpreter:</summary>
      <section class="rtl text-right">
        <p class="bolder">
          هدف این دیزاین پترن Parse کردن یک String ساختارمند ،‌
          و تبدیل Segment های ان String ساختارمند به object میباشد
        </p>
        <p class="bolder">
          این design pattern در جایی استفاده میشود که بخواهیم یک string
          ساختارمند را parse کنیم و در مواقعی هر segment انرا به ابجکت تبدیل کنیم !!!
        </p>
        <p>
          مثلا برنامه نویس Client ما میخواهد یک String ساختارمند را از ورودی
          بگیرد و انرا را در کد نهایی parse و تجزیه و تحلیل کند و سپس هر Segment
          از ان String ساختارمند را میخواهد تبدیل به یک object بکند !!!
        </p>
        <p>
          اما پردازش ان string ساختارمند و ایجاد object برای هر segment از ان string ساختار مند ،
          در کد نهایی ، ممکن است کاری پیچیده و سخت برای برنامه نویس client باشد و قطعا انجام این دو عملیات
          کد نهایی ما را شلوغ ، پیچیده و کثیف خواهد کرد !!!
        </p>
        <p>
          برای اینکه ان string ساختارمند parse شود و ابجکت هایی به ازای هر segment ان string ساختارمند ایجاد شود
          و سپس در صورت لزوم ان ابجکت ها به برنامه نویس کلاینت تحویل داده شود میتوانیم از
          دیزاین پترن interpreter استفاده کنیم !!!
        </p>
        <p>
          اینطوری پیچیدگی عملیات parse ، ان string ساختارمند و همچنین پیچیدگی عملیات
          تبدیل هر segment از ان string ساختارمند ، به object از چشم برنامه نویس client مخفی میشود
          و در نهایت این باعث میشود کد نهایی ما دیگر شلوغ و کثیف و پیچیده نشود !!!
        </p>
        <section>
          <details>
            <summary class="bolder">
              درک عمیق‌ تر :
            </summary>
            <ul>
              <li>
                <details>
                  <summary>
                    به طور مثال میخاهیم اطلاعات user ها را از یک فایل csv دریافت کنیم
                    و به object تبدیل کنیم !!! :
                  </summary>
                  <p>
                    میتوانیم برای انجام این کار از دیزاین پترن interpreter استفاده کنیم ، و parse ان فایل csv
                    و همچنین ایجاد object به ازای هر record از ان فایل csv را برعهده دیزاین پترن Interpreter بسپاریم!!!
                  </p>
                  <p>
                    اینطوری برنامه نویس client ما درگیر parse آن فایل csv و درگیر پیچیدگی هایش نمیشود
                    و همچنین درگیر ساخت object و پیچیدگی هایش از کلاس user به ازای هر record از ان فایل csv نمیشود !!!

                  </p>
                  <p class="bolder">
                    ممکنه در ان فایل csv رکورد های تکراری وجود داشته باشد یعنی ممکن است اطلاعات یک فرد دو بار در ان فایل موجود باشد برای حل
                    این مشکل و جلوگیری از ساخت object های تکراری در سیستم میتوانیم از دیزاین پترن flyWeight در interpreter استفاده کنیم !!!
                  </p>
                </details>
              </li>
              <li>
                <details>
                  <summary>
                    میتوانیم از این design pattern برای انجام عملیات form Validation استفاده کنیم !!!‌ :
                  </summary>
                  <p>
                    به این صورت که rule ها را از برنامه نویس client به صورت یک string ساختارمند و معنا دار میگیریم
                    و سپس بواسطه دیزاین پترن Interpreter ان string ساختار مند و معنا دار را parse میکنیم و بعد
                    آن rule هایی که درون ان string ساختارمند و معنا دار هست را تبدیل به object میکنیم و بعد
                    میتوانیم فورم و ورودی برنامه نویس client را به راحتی validate کنیم
                    و یا میتوانیم آن rule object ها را تحویل برنامه نویس بدهیم !!!
                  </p>
                  <p>
                    اینطوری به جای اینکه برنامه نویس client خودش به صورت دستی از هر rule یک ابجکت بسازد
                    و با class و object هر rule درگیر شود میتواند با دادن یک string معنا دار
                    به کلاس interpreter ورودی خود را validation کند و همچنین
                    در صورت لوزوم میتواند به ابجکت rule مورد نظر خود دسترسی پیدا کند !!!
                  </p>
                  <p class="bolder">
                    در اینجا میتوانیم از دیزاین پترن factory برای ساخت rule object ها در interpreter استفاده کنیم !!!
                  </p>
                </details>
              </li>
              <li>
                <details>
                  <summary>
                    مثال Parse<bdo>-></bdo>
                    <bdi>Json</bdi>
                    در Javascript و مثال uniserialize
                    <bdo dir="">-></bdo>
                    <bdi>
                      serialize query string
                    </bdi> در php :
                  </summary>
                  <p>
                    مثلا زمانی که JavaScript یک متن Json را میخواهد parse کند جاوا اسکریپت
                    ان Json String را به این Design pattern میدهد حالا این دیزاین پترن
                    ان Json String را تجزیه میکند و سپس به Object تبدیل میکند !!!
                  </p>
                  <p>
                    ویا زمانیکه php میخواهد یک serialize query string را unserialize کند ،
                    php ان serialize query string را به این design pattern میدهد و سپس
                    این دیزاین پترن آن serialize query string را تحلیل و تجزیه میکند و بعد با توجه
                    به ان تحلیل و تجزیه serialize query string یک object تحویل ما میدهد !!!
                  </p>
                </details>
              </li>
            </ul>
          </details>
        </section>
      </section>
    </details>
  </li>
  <li>
    <details>
      <summary>Iterator:</summary>
      <section class="rtl text-right">
        <p class="bolder">
          هدف این دیزاین پترن encapsualte عملیات iterate بر روی یک iterable در Unit مجزا میباشد !!!
        </p>
        <p class="bolder">
          این design pattern در جایی استفاده میشود که عملیات iterate وجود داشته باشد
          و یا iterate بر روی یک iterable پیچیده و سخت باشد و ما میخواهیم
          پیچیدگی iterate بروی ان iterable را از چشم برنامه نویس client مخفی کنیم !!!
        </p>
        <p>
          مثلا برنامه نویس client در کدنهایی میخواهد بر روی یک iterable عملیات iterate انجام دهد ،‌
          اما ممکن است انجام عملیات iterate بر روی ان iterable برای برنامه نویس client
          کاری پیچیده و سخت باشد و همچنین کد نهایی ما را پیچیده و کثیف بکند !!!
        </p>
        <p>
          برای حل این مشکل با استفاده از دیزاین پترن Iterator میتوانیم پیچیدگی
          iterate بر روی یک iterable را در یک unit مجزا Encapsulate
          و از چشم برنامه نویس نهایی مخفی کنیم !!!
        </p>
        <p>
          اینطوری برنامه نویس client ما با استفاده از یک object و یا یک کلاس iterator میتواند
          بر روی آن iterable عملیات iterate را به سادگی و بدون درگیر شدن با پیچیدگی های آن انجام دهد
          و همچنین استفاده از این دیزاین پترن باعث میشود کد نهایی ما شلوغ و پیچیده و کثیف نشود
        </p>
        <details>
          <summary class="bolder">
            نکات تکمیلی :
          </summary>
          <ol>
            <li>
              این دیزاین پترن پیچیدگی iterate بر روی یک
              iterable را در یک unit مجزا Encapsulate میکند !!!
            </li>
          </ol>
        </details>
      </section>
    </details>
  </li>
  <li>
    <details>
      <summary>Mediator:</summary>
      <section class="rtl text-right">
        <p class="bolder">
          هدف این دیزاین پترن ایجاد یک راه برای interact و communication آبجکت ها با یکدیگر ، بدون داشتن رابطه با هم میباشد !!!
        </p>
        <p class="bolder">
          <!--
          این design pattern در جایی استفاده میشود که چندین object برای communication کردن با هم ،
          باید با هم رابطه داشته باشند و یکدیگر را بشناسند و بهم اشراف داشته باشند
          -->
          این design pattern در جایی استفاده میشود که چندین object باید همدیگر را بشناسند
          و بهم اشراف داشته باشند و با هم رابطه داشته باشند و یکدیگر را در خود compose کنند
          تا بتوانند با هم interact و communication کنند !!!
        </p>
        <p>
          مثلا برنامه نویس client ما در کد نهایی ، object هایی دارد
          که انها برای interact و Communication کردن با هم ،
          باید یکدیگر را بشناسند و به هم اشراف داشته باشند !!!
        </p>
        <p>
          اما شناساندن همه ی object ها به یکدیگر در کدنهایی ، ممکن است
          کاری پیچیده ، سخت ، هزینه بر و زمانبر باشد و برنامه نویس client
          ما را درگیر پیچیدگی ایجاد روابط بین object ها بکند و همچنین
          قطعا انجام این کار ، کدنهایی ما را شلوغ و پیچیده و کثیف میکند !!!
        </p>

        <p>
          برای حل این مشکلات ما میتوانیم از دیزاین پترن Mediator استفاده کنیم و مسعولیت communicate و interact
          آن آبجکت ها با یکدیگر را برعهده mediator بسپاریم سپس این design pattern ما را مجبور میکند تا به جای اینکه
          object هایی را که میخواهند با هم interact و communication کنند را به همدیگر بشناسانیم و معرفی کنیم ،
          آنها را فقط به mediator بشناسانیم و معرفی کنیم !!!
        </p>
        <p>
          حالا بواسطه دیزاین پترن mediator آن object هایی که میخواهند با هم communicate و interact کنند ، فقط
          با شناخت mediator و معرفی شدن به mediator میتوانند با یکدیگر communicate و interact کنند !!!
        </p>
        <p>
          به این صورت که درخواست خود را به mediator میدهند و چون mediator به همه object ها اشراف دارد و
          همه ی object ها را میشناسد و با همه object ها ارتباط دارد آن درخواست را تحویل object مورد نظر میدهد !!!
        </p>
        <p>
          بواسطه دیزاین پترن mediator روابط و چسبندگی بین object هایی که میخواهند با هم communicate و interact کنند ،
          حذف میشود و یا کاهش پیدا میکند به این صورت که دیگر لازم نیست آن object ها برای communicate و interact باهم ،
          یکدیگر را بشناسند و با هم رابطه داشته باشند و فقط با شناخت و داشتن رابطه با mediator ، میتوانند با هم
          communicate و interact کنند
        </p>
        <p>
          که این باعث شده تا برنامه نویس client ما دیگر در گیر پیچیدگی ایجاد روابط بین ان object ها
          و شناساندن ان object ها به یکدیگر نشود و در نتیجه استفاده از mediator باعث میشود که
          کد نهایی ما شلوغ کثیف و پیچیده نشود !!!
        </p>
        <details>
          <summary class="bolder">نکات تکمیلی :</summary>
          <ol>
            <li>
              این design pattern یک unit به منظور Encapsulate کردن روابط بین object ها ایجاد میکند !!!
            </li>
            <li>
              این design pattern روابط بین object ها را برای ما کاهش میدهد
            </li>
            <li>
              <p>
                برای درک بهتر این design pattern چند client را در نظر بگیرید که میخواهند با هم گفت و گو کنند و بهم پیام ارسال کنند اما برای
                گفت و گو آن client ها باید از هم خبر داشته باشند و یکدیگر را بشناسند و با هم رابطه داشته باشند تا بتوانند بهم پیام بدهند !!!
              </p>
              <p>
                اما این کار معقولانه نیست که client ها یکدیگر را بشناسند و از هم خبر داشته باشند و باهم رابطه داشته باشند
                تا بتوانند بهم پیام بدهند !!!
              </p>
              <p>
                برای حل این مشکل ، client ها میتوانند خودشان را به یک mediator که در این مثال mediator ما server است
                register کنند و از mediator و یا همان server بخواهند تا به client مورد نظرشان پیام را ارسال بکند اینطوری دیگر
                نیاز نیست client ها برای ارسال پیام بهم ، یکدیگر را بشناسند و از هم با خبر باشند !!!
              </p>
              <p class="bolder">
                میبینیم که معماری کلاینت سروری درست شبیه به این design pattern میباشد
                و همچنین messanger ها هم از این معماری استفاده میکنند !!!!
              </p>

            </li>
          </ol>
        </details>

      </section>
    </details>
  </li>
  <li>
    <!--
 اما گاها نیاز دارد تا تغییرات قبل را بر روی ان object اعمال کند
 اما
-->
    <details>
      <summary>Memento:</summary>
      <section class="rtl text-right">
        <p class="bolder">
          هدف این دیزاین پترن Track تغییراتی است که بر روی یک Unit و داده هایش اعمال میشود
          و همچنین تولید snapShot و image از ان تغییرات و سپس فراهم کردن امکان restore
          آن unit به تغییرات و snapShot های قبلی میباشد !!!
        </p>
        <p class="bolder">
          این design pattern در جایی استفاده میشود که یک object و داده هایش داعما در حال تغییر و
          تحول باشند و ما میخواهیم ان تغییرات را track کنیم و از روی هر تغییر یک SnapShot برداریم و هر
          تغییر را save کنیم تا بتوانیم در آینده و یا هر موقع که نیاز بود تغییرات قبلی را بر روی آن object
          بواسطه snapShot ها ، اعمال کنیم و ان object را به تغییرات قبلی و گذشته restore کنیم !!!
        </p>
        <p>
          مثلا برنامه نویس client ما در کدنهایی object ای دارد که دیتا های ان object زیاد تغییر میکند
          و برنامه نویس client ما باید هر از گاهی دیتا های ان object را تغییر دهد اما در بعضی از موارد
          ممکن است تغییراتی که بر روی دیتاهای ان object اعمال میکند ، تغییرات تکراری ای باشد که در گذشته
          بر روی دیتاهای ان object اعمال کرده و چون آن تغییرات را در جایی save نکرده و یا از روی ان
          تغییرات snap shot ای بر نداشته مجددا برنامه نویس client ما باید از اول تغییرات تکراری گذشته را
          بر روی دیتاهای ان object اعمال کند !!!
        </p>
        <p>
          برای اینکه بتوانیم تغییراتی که بر روی یک object اعمال میشود را ذخیره کنیم و track کنیم
          و از هر تغییر بتوانیم یک snapShot برداریم تا در صورت لزوم
           بتوانیم آن object را به تغییرات گذشته و به قبل برگردانیم باید از دیزاین پترن Memento استفاده کنیم
        </p>
        <p>
          به این صورت که این design pattern مارا مجبور میکند تا کاری کنیم که بتوان از ان آبجکت snapShot و یا
          image تهیه کرد و همچنین بتوان یک snapShot و یا یک image را بر روی آن آبجکت restore کرد و یا ان
          object را بواسطه یک image و یا snapShot به تغییرات گذشته برگرداند !!!
        </p>
        <p>
          بواسطه دیزاین پترن Memento برنامه نویس client میتواند از هر تغییری که بر روی یک object اعمال میشود یک snapShot تهیه کند
          و هر موقع که نیاز بود آن object را به تغییرات قبل و یا به snapShot های قبلی برگرداند همچنین دیگر نیاز نیست برنامه نویس client
          ما برای برگرداندن دیتاهای یک object به قبل آن دیتاها را از اول برای ان object به صورت دستی set کند و فقط با داشتن snapShot
          میتواند به راحتی آن object را به قبل برگرداند !!!
        </p>
        <p>
          اینطوری کار برنامه نویس client ما راحت شده و دیگر نیاز نیست وقتش را برای برگرداندن دیتاهای
          یک object به گذشته و set کردن دیتا های ان object از اول به صورت دستی تلف کند !!!
        </p>
        <details>
          <summary class="bolder">نکات تکمیلی:</summary>
          <ul>
            <li>
              <details>
                <summary class="bolder">
                  تفاوت memento با Prototype :
                </summary>
                <ul>
                  <li>
                    <p>
                      بواسطه memento از object ای که دیتاهایش داعما در حال تغییر میباشد
                      در هر مرحله میتوان یک snapShot و یا یک clone و یا یک backup گرفت
                      و سپس هر موقع که نیاز بود میتوان ان snapShot یا clone و یا backup
                      را بر روی ان object برگرداند و restore ویا revert کرد !!!
                    </p>
                  </li>
                  <li>
                    <p>
                      اما بواسطه prototype فقط میتوانیم از object موردنظرمان یک clone بگیریم و prototype
                      این وظیفه را ندارد تا آن clone را بر روی object اصلی restore کند !!!

                      اگر object اصلی تغییری کرد clone ای را
                      که از ان گرفته را بر روی object اصلی restore کند زیرا وظیفه ی prototype
                      فقط گرفتن clone از یک object میباشد !!!
                    </p>
                  </li>
                </ul>
              </details>
            </li>
            <li>
              <p>
                پس هدف دیزاین پترن Memento ایجاد یک راهکار برای ذخیره تغییراتی که بر روی یک object اعمال میشود به صورت
                snap shot و سپس فراهم کردن امکان بازگشت ان تغییرات اعمال شده به ان object به قبل میباشد !!!
              </p>
            </li>
            <li>
              <p>
                در صورتیکه برای گرفتن snapShot از object موردنظرمان نیاز بود تا انرا clone کنیم میتوانیم از
                دیزاین پترن Prototype برای clone کردن استفاده کنم !!!
              </p>
            </li>
            <li>
              <p>
                این دیزاین پترن backup گرفتن از یک object و همچنین
                restore ان backup ها بر روی ان object را برای ما محقق ساخته !!!
              </p>
            </li>
            <li>
              <p>
                کتابخانه ReactJs برای ذخیره state کامپوننت هایش و برای اینکه تغییر
                state یک component را متوجه شود و کامپوننت را ReRender کند و
                برای اینکه به ما تفاوت state را قبل از تغییر و بعد از تغییر نشان دهد
                از دیزاین پترن Memento استفاده میکند !!!
              </p>
            </li>
            <li>
              <p>
                سیستم مدیریت محتوای Wordpress از دیزاین پترن Memento استفاده میکند
                تا بتواند از تغییراتی که بر روی یک Article اعمال میشود را Track بکند و از
                هر تغییر یک SnapShot تهیه بکند تا در صورت نیاز به کاربر بتواند history
                تغییرات را نشان بدهد و یا آن article را به تغییرات قبلی برگرداند !!!
              </p>
            </li>
          </ul>
        </details>
      </section>
    </details>
  </li>


  <hr>
  <li>
    <details>
      <summary>Observer:</summary>
      <section class="text-right rtl">
        در این chain اگر به هر دلیلی انجام یک کار fail شد عموما دیگر به سراغ انجام کار بعدی نمیرویم

        ===
        در chainOfRes انجام کار های پشت سر هم و متصل به هم و اگر در هر کار عملیات return انجام شود
        دیگر ادامه کار ها اجرا نمیشود
        اما در این الگو اگرreturn شود همچنان ادامه اجرا برقرار است !!!
        ====
        توی observer یک unit مسعول ذخیره هستش و ان یونیت با حلقع کار ها  را اجرا میکند
        اما در chain ما یونیتی که chain ها را ذخیره کند نداریم و هر unit باید از یونیت بعد از خودش اطلاع داشته باشد و انرا اجرا کند !!!
      </section>
    </details>
  </li>
  <li>
    <details>
      <summary>Visitor:</summary>
      <section class="rtl text-right">
        <p>
          هدف این design pattern
          <!--
          عملیاتی که باید بر روی یک object انجام شود در class های مجزا
          -->
          <!--
          یک ابجکت را در یک سیستم قابل visit شدن میکند تا و همچنین عملیات هایی که باید بر روی ان انجام شود را
          در کلاس های مجزا ....
          -->
          <!--
          و همچنین کاری میکند تا عملیاتی که باید بر روی یک ابجکت انجام شود در کلاس های مجزا پیاده سازی بشوند !!!
          -->
        </p>
      </section>
    </details>
  </li>
  <li>
      <details>
          <summary>Template:</summary>
          <section>
              <p class="bolder">
                  استاندارد سازی
              </p>
              <p class="bolder"></p>
          </section>
      </details>
  </li>
  <li>
    <details>
      <summary>Strategy:</summary>
    </details>
  </li>
  <li>
    <details>
      <summary>State:</summary>
    </details>
  </li>
</ol>
</body>
</html>