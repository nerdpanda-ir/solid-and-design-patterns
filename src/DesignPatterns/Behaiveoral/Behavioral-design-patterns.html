<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Behavioral-design-patterns</title>
  <link rel="stylesheet" href="../../../assets/css/pages/BehavioralDesignPatterns.css">
</head>
<body>
<ol>
  <li>
    <!--
    داینامیک بودن
    اضافه کردن handler
    -->
    <details>
      <summary>Chain Of Responsibility :</summary>
      <section class="rtl text-right">
        <section>
          هدف دیزاین پترن Chain Of Responsibility :
          <ol>
            <li>
              <p class="bolder">
                encapsulate کار هایی که باید برای انجام یک task ،
                پشت سر هم انجام شوند در unit های مجزا است
              </p>
            </li>
            <li>
              <p class="bolder">
                متصل کردن ان unit ها به یکدیگر در کد به صورت دانه های یک زنجیر ،
                به طوری که هر unit باید از unit بعدی خود که قرار است اجرا شود مطلع باشد
                و هر unit باید بتواند unit بعد از خودش را اجرا کند !!
              </p>
            </li>
          </ol>
        </section>
        <section>
          زمانی از این design pattern استفاده میکنیم که :
          <ol>
            <li>
              <p class="bolder">
                برای انجام شدن یک task ، باید چندین کار ، به صورت پشت سر هم انجام شود
                و یا باید برای انجام ان task باید چندین handler پشت سرهم اجرا شود !!!
              </p>
            </li>
            <li>
              <p class="bolder">
                ما میخواهیم هر گاه که نیاز بود به صورت Dynamic
                کاری ویا handler ی را به ان زنجیره اضافه و یا کم کنیم !!!
              </p>
            </li>
          </ol>
        </section>
        <p>
          مثلا برنامه نویس client ما نیاز دارد تا یک task را با استفاده از انجام شدن
          چندین کار پشت سر هم انجام دهد اما برنامه نویس client باید
          به ازای انجام هر کار در کد نهایی ، از یک موجودیت و method هایش استفاده کند :
          <br>
          <img src="../../../assets/img/ChainOfResponsibility1.svg" alt="" class="">
        </p>
        <p>
          ممکن است استفاده از هر موجودیت و متد هایش برای انجام یک کار ،
          در کد نهایی پیچیدگی هایی را به همراه داشته باشد
          و ما نمیخواهیم برنامه نویس client ما درگیر ان پیچیدگی ها شود
          و همچنین کد نهایی ما پیچیده و شلوغ و کثیف شود !!!
        </p>
        <p>
          در اینجا برای حل این مشکل میتوانیم از دیزاین پترن
          chain of responsibility استفاده کنیم به این
          صورت که این design pattern ما را محبور میکند تا
          هر کاری را که بواسطه استفاده از یک موجودیت و متد هایش
          برای انجام ان task در کدنهایی انجام داده ایم را در یک
          unit مجزا encapsulate کنیم و این امکان را به ان unit بدهیم که
          بتواند در کد نهایی به یک unit دیگر از جنس خودش متصل شود !!!
        </p>
        <img src="../../../assets/img/ChainOfResponsibility2.svg" alt="">
        <p>
          اینطوری پیچیدگی انجام هر کار در unit های مجزا encapsulate ،
          و از چشم برنامه نویس client مخفی میشود و دیگر لازم نیست
          برنامه نویس client با پیچیدگی انجام هر کار درگیر شود
          و همچنین با متصل شدن ان unit ها به یکدیگر در کدنهایی مثل یک زنجیر ،
          به برنامه نویس کلاینت این گارانتی داده میشود که آن کار ها حتما پشت سر هم
          انجام میشوند و بین انها هیچ وقفه ای برای انجام کار دیگری و یا .... نیوفتد
          و بعلاوه به برنامه نویس client این گارانتی داده میشود که بتواند به صورت Dynamic
          هر گاه که نیاز داشت کار و یا handler ای را به ان زنجیره اضافه و یا کم کند !!!
          و در نتیجه بواسطه این design pattern کد نهایی ما تمیز و ساده و خوانا میشود !!!
        </p>
      </section>
      <section class="text-right rtl">
        <h1>نکات تکمیلی :‌</h1>
        <ol>
              <li>
                <details>
                  <summary>
                    تفاوت Chain Of Responsibility با command :
                  </summary>
                  <section>
                    <p>
                      زمانی از دیزاین پترن command استفاده میشود که برای انجام
                      یک task فقط با یک موجودیت و method هایش سروکار داشته باشیم !!!
                      <br>
                      اما زمانی از دیزاین پترن chain of responsibility استفاده میکنیم
                      که برای انجام یک task با چندین موجودیت و method هایشان درگیر باشیم !!!
                    </p>
                    <p>
                      از موجودیت های command میتوان درون chain of responsibility استفاده کرد !!!
                    </p>
                    <img src="../../../assets/img/ChainOfResponsibility3.svg" alt="" style="with:100%;">
                  </section>
                </details>
              </li>
              <li>
                تفاوت با observer :
              </li>
            </ol>
      </section>
    </details>
  </li>
  <li>
    <details>
      <summary>Command:</summary>
      <section class="rtl text-right">
        <p class="bolder">
          هدف این دیزاین پترن encapsulate درخواست ای که برای انجام یک task
          به یک Entity ارسال میشود در یک unit مجزا میباشد
        </p>
        <p class="bolder">
          در جایی استفاده میشود که برای انجام یک task باید
          متد هایی از یک کلاس ، پشت سر هم صدا زده بشود
        </p>
        <p>
          مثلا برنامه نویس client ما میخواهد یک task ای را انجام دهد و برای انجام ان
          task نیاز دارد تا چندین Method را از یک موجودیت به صورت پشت سر هم صدا بزند
          اما اینکار باعث میشود برنامه نویس client ما برای انجام ان task با آن موجودیت
          و متد هایش درگیر شود و همچنین اگر برنامه نویس client ما متد های زیادی را از ان موجودیت
          برای انجام ان task پشت سر هم صدا بزند ، کد نهایی ما پیچیده و شلوغ و کثیف میشود !!!
        </p>
        <p>
          برای حل این مشکل میتوانیم از دیزاین پترن command استفاده کنیم
          به این صورت که این design pattern مارا مجبور میکند تا متد هایی را
          که از ان موجودیت برای انجام ان task پشت سر هم صدا زده ایم را در یک
          unit مجزا encapsulate کنیم
        </p>
        <p>
          اینطوری برنامه نویس client ما برای انجام ان task درگیر استفاده از چندین method از یک موجودیت نمیشود
          زیرا بواسطه دیزاین پترن command میتواند با صدا زدن یک method از یونیت command ، ان task را انجام دهد
          و همچنین استفاده از دیزاین پترن command باعث شده که کد نهایی ما شلوغ ، پیچیده ، و کثیف نشود !!!
        </p>
      </section>
      <section class="rtl text-right">
        <details>
          <summary class="bolder">نکات تکمیلی :</summary>
          <ol>
            <li>
              این design pattern موجودیت هایی را ایجاد میکند که کار ان موجودیت ها
              انجام یک درخواست با استفاده از یک unit است !!!
            </li>
            <li>
              این design pattern زمانی مفید واقع میشود که یک تسک باید به واسطه متد های یک موجودیت انجام شود
            </li>
            <li>
              <details>
                <summary>تفاوت دیزاین پترن command با Facade : </summary>
                <section>
                  command برای یک کلاس اما facade میتواند برای چندین کلاس باشد
                  و شاید متدی داشته باشد که از متد های چندین کلاس برای انجام یک کار استفاده کند !!!!
                  اما هر command دارای فقط یک متد و فقط برای انجام یک کار یا درخواست از یک موجودیت استفاده میشود
                  اما یک کلاس Facade میتواند چندین کار را انجام دهد و چندین متد داشته باشد‌!!!
                </section>
              </details>
            </li>
            <li>
              میتوانیم command هایی ایجاد کنیم و به عنوان callBack بدهیم به ابجکت ها
              تا هر موقع نیاز بود ان کامنتد ها را اجرا کنند مثلا دو کامند success , fail میسازیم
              و ان دو را پاس میدهیم به یک ابجکت حالا ان ابجکت هر موقع که یک کاری با موفقیت انجام داد
              به ابجکت کامند success درخواست میدهد تا اجرا شود اما اگر انجام ان کار Fail شد
              به کامند Fail درخواست میدهد تا اجرا شود !!!
            </li>
            <li>
              <p>
                این design pattern اصل single responsibility را برای متد هایمان مهیا میسازد یعنی هر متد
                باید یک کار انجام دهد و اگر متدی در ان کلاس داریم که باید بواسطه متد های دیگر ان کلاس ،
                یک کاری را انجام داده آن متد اصل single responsibility را نقض کرده !!!
              </p>
              <p>
                با استفاده از دیزاین پترن command میتوانیم این مشکل را حل کنیم و در هیچ کلاسی متدی نداشته باشیم
                که بواسطه متد های دیگر از همان کلاس کاری را انجام دهد !!!
              </p>
            </li>
            <li>
              <p>
                میتوانیم در یک موجودیت command ، چندین متد helper داشته باشیم
                که هر یک از آنها ، متد هایی را از ابجکت اصلی پشت سر هم صدا میزنند !!!
              </p>
              <p>
                سپس در زمانیکه متدی از موجودیت command برای انجام درخواست اجرا شد
                میتوانیم ان متد های helper را در ان متد صدا بزنیم !!!
              </p>
            </li>
          </ol>
        </details>
      </section>
    </details>
  </li>
  <li>
    <details>
      <summary>Interpreter:</summary>
      <section class="rtl text-right">
        <p class="bolder">
          هدف این دیزاین پترن Parse کردن یک String ساختارمند ،‌
          و تبدیل Segment های ان String ساختارمند به object میباشد
        </p>
        <p class="bolder">
          این design pattern در جایی استفاده میشود که بخواهیم یک string
          ساختارمند را parse کنیم و در مواقعی هر segment انرا به ابجکت تبدیل کنیم !!!
        </p>
        <p>
          مثلا برنامه نویس Client ما میخواهد یک String ساختارمند را از ورودی
          بگیرد و انرا را در کد نهایی parse و تجزیه و تحلیل کند و سپس هر Segment
          از ان String ساختارمند را میخواهد تبدیل به یک object بکند !!!
        </p>
        <p>
          اما پردازش ان string ساختارمند و ایجاد object برای هر segment از ان string ساختار مند ،
          در کد نهایی ، ممکن است کاری پیچیده و سخت برای برنامه نویس client باشد و قطعا انجام این دو عملیات
          کد نهایی ما را شلوغ ، پیچیده و کثیف خواهد کرد !!!
        </p>
        <p>
          برای اینکه ان string ساختارمند parse شود و ابجکت هایی به ازای هر segment ان string ساختارمند ایجاد شود
          و سپس در صورت لزوم ان ابجکت ها به برنامه نویس کلاینت تحویل داده شود میتوانیم از
          دیزاین پترن interpreter استفاده کنیم !!!
        </p>
        <p>
          اینطوری پیچیدگی عملیات parse ، ان string ساختارمند و همچنین پیچیدگی عملیات
          تبدیل هر segment از ان string ساختارمند ، به object از چشم برنامه نویس client مخفی میشود
          و در نهایت این باعث میشود کد نهایی ما دیگر شلوغ و کثیف و پیچیده نشود !!!
        </p>
        <section>
          <details>
            <summary class="bolder">
              درک عمیق‌ تر :
            </summary>
            <ul>
              <li>
                <details>
                  <summary>
                    به طور مثال میخاهیم اطلاعات user ها را از یک فایل csv دریافت کنیم
                    و به object تبدیل کنیم !!! :
                  </summary>
                  <p>
                    میتوانیم برای انجام این کار از دیزاین پترن interpreter استفاده کنیم ، و parse ان فایل csv
                    و همچنین ایجاد object به ازای هر record از ان فایل csv را برعهده دیزاین پترن Interpreter بسپاریم!!!
                  </p>
                  <p>
                    اینطوری برنامه نویس client ما درگیر parse آن فایل csv و درگیر پیچیدگی هایش نمیشود
                    و همچنین درگیر ساخت object و پیچیدگی هایش از کلاس user به ازای هر record از ان فایل csv نمیشود !!!

                  </p>
                  <p class="bolder">
                    ممکنه در ان فایل csv رکورد های تکراری وجود داشته باشد یعنی ممکن است اطلاعات یک فرد دو بار در ان فایل موجود باشد برای حل
                    این مشکل و جلوگیری از ساخت object های تکراری در سیستم میتوانیم از دیزاین پترن flyWeight در interpreter استفاده کنیم !!!
                  </p>
                </details>
              </li>
              <li>
                <details>
                  <summary>
                    میتوانیم از این design pattern برای انجام عملیات form Validation استفاده کنیم !!!‌ :
                  </summary>
                  <p>
                    به این صورت که rule ها را از برنامه نویس client به صورت یک string ساختارمند و معنا دار میگیریم
                    و سپس بواسطه دیزاین پترن Interpreter ان string ساختار مند و معنا دار را parse میکنیم و بعد
                    آن rule هایی که درون ان string ساختارمند و معنا دار هست را تبدیل به object میکنیم و بعد
                    میتوانیم فورم و ورودی برنامه نویس client را به راحتی validate کنیم
                    و یا میتوانیم آن rule object ها را تحویل برنامه نویس بدهیم !!!
                  </p>
                  <p>
                    اینطوری به جای اینکه برنامه نویس client خودش به صورت دستی از هر rule یک ابجکت بسازد
                    و با class و object هر rule درگیر شود میتواند با دادن یک string معنا دار
                    به کلاس interpreter ورودی خود را validation کند و همچنین
                    در صورت لوزوم میتواند به ابجکت rule مورد نظر خود دسترسی پیدا کند !!!
                  </p>
                  <p class="bolder">
                    در اینجا میتوانیم از دیزاین پترن factory برای ساخت rule object ها در interpreter استفاده کنیم !!!
                  </p>
                </details>
              </li>
              <li>
                <details>
                  <summary>
                    مثال Parse<bdo>-></bdo>
                    <bdi>Json</bdi>
                    در Javascript و مثال uniserialize
                    <bdo dir="">-></bdo>
                    <bdi>
                      serialize query string
                    </bdi> در php :
                  </summary>
                  <p>
                    مثلا زمانی که JavaScript یک متن Json را میخواهد parse کند جاوا اسکریپت
                    ان Json String را به این Design pattern میدهد حالا این دیزاین پترن
                    ان Json String را تجزیه میکند و سپس به Object تبدیل میکند !!!
                  </p>
                  <p>
                    ویا زمانیکه php میخواهد یک serialize query string را unserialize کند ،
                    php ان serialize query string را به این design pattern میدهد و سپس
                    این دیزاین پترن آن serialize query string را تحلیل و تجزیه میکند و بعد با توجه
                    به ان تحلیل و تجزیه serialize query string یک object تحویل ما میدهد !!!
                  </p>
                </details>
              </li>
            </ul>
          </details>
        </section>
      </section>
    </details>
  </li>
  <li>
    <details>
      <summary>Iterator:</summary>
      <section class="rtl text-right">
        <p class="bolder">
          هدف این دیزاین پترن encapsualte عملیات iterate بر روی یک iterable در Unit مجزا میباشد !!!
        </p>
        <p class="bolder">
          این design pattern در جایی استفاده میشود که عملیات iterate وجود داشته باشد
          و یا iterate بر روی یک iterable پیچیده و سخت باشد و ما میخواهیم
          پیچیدگی iterate بروی ان iterable را از چشم برنامه نویس client مخفی کنیم !!!
        </p>
        <p>
          مثلا برنامه نویس client در کدنهایی میخواهد بر روی یک iterable عملیات iterate انجام دهد ،‌
          اما ممکن است انجام عملیات iterate بر روی ان iterable برای برنامه نویس client
          کاری پیچیده و سخت باشد و همچنین کد نهایی ما را پیچیده و کثیف بکند !!!
        </p>
        <p>
          برای حل این مشکل با استفاده از دیزاین پترن Iterator میتوانیم پیچیدگی
          iterate بر روی یک iterable را در یک unit مجزا Encapsulate
          و از چشم برنامه نویس نهایی مخفی کنیم !!!
        </p>
        <p>
          اینطوری برنامه نویس client ما با استفاده از یک object و یا یک کلاس iterator میتواند
          بر روی آن iterable عملیات iterate را به سادگی و بدون درگیر شدن با پیچیدگی های آن انجام دهد
          و همچنین استفاده از این دیزاین پترن باعث میشود کد نهایی ما شلوغ و پیچیده و کثیف نشود
        </p>
        <details>
          <summary class="bolder">
            نکات تکمیلی :
          </summary>
          <ol>
            <li>
              این دیزاین پترن پیچیدگی iterate بر روی یک
              iterable را در یک unit مجزا Encapsulate میکند !!!
            </li>
          </ol>
        </details>
      </section>
    </details>
  </li>
  <li>
    <details>
      <summary>Mediator:</summary>
      <ol>
        
      </ol>
    </details>
  </li>





  <li>
    <details>
      <summary>Observer:</summary>
      <section class="text-right rtl">
        در این chain اگر به هر دلیلی انجام یک کار fail شد عموما دیگر به سراغ انجام کار بعدی نمیرویم

        ===
        در chainOfRes انجام کار های پشت سر هم و متصل به هم و اگر در هر کار عملیات return انجام شود
        دیگر ادامه کار ها اجرا نمیشود
        اما در این الگو اگرreturn شود همچنان ادامه اجرا برقرار است !!!
        ====
        توی observer یک unit مسعول ذخیره هستش و ان یونیت با حلقع کار ها  را اجرا میکند
        اما در chain ما یونیتی که chain ها را ذخیره کند نداریم و هر unit باید از یونیت بعد از خودش اطلاع داشته باشد و انرا اجرا کند !!!
      </section>
    </details>
  </li>
  <li>
    <details>
      <summary>Visitor:</summary>
      <section class="rtl text-right">
        <p>
          هدف این design pattern
          <!--
          عملیاتی که باید بر روی یک object انجام شود در class های مجزا
          -->
          <!--
          یک ابجکت را در یک سیستم قابل visit شدن میکند تا و همچنین عملیات هایی که باید بر روی ان انجام شود را
          در کلاس های مجزا ....
          -->
          <!--
          و همچنین کاری میکند تا عملیاتی که باید بر روی یک ابجکت انجام شود در کلاس های مجزا پیاده سازی بشوند !!!
          -->
        </p>
      </section>
    </details>
  </li>
  <li>
    <details>
      <summary>Memento:</summary>
    </details>
  </li>

</ol>
</body>
</html>